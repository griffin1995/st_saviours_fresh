### Define and Use BaseSettings Model in Python

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how to define a configuration model inheriting from BaseSettings. It shows how fields can be configured with aliases, choices, and imported functions, and how to set an environment variable prefix. The output shows the model's data dumped after initialization, with environment variables overriding defaults.

```python
from collections.abc import Callable
from typing import Any

from pydantic import (
    AliasChoices,
    AmqpDsn,
    BaseModel,
    Field,
    ImportString,
    PostgresDsn,
    RedisDsn,
)

from pydantic_settings import BaseSettings, SettingsConfigDict


class SubModel(BaseModel):
    foo: str = 'bar'
    apple: int = 1


class Settings(BaseSettings):
    auth_key: str = Field(validation_alias='my_auth_key')  # (1)!

    api_key: str = Field(alias='my_api_key')  # (2)!

    redis_dsn: RedisDsn = Field(
        'redis://user:pass@localhost:6379/1',
        validation_alias=AliasChoices('service_redis_dsn', 'redis_url'),  # (3)!
    )
    pg_dsn: PostgresDsn = 'postgres://user:pass@localhost:5432/foobar'
    amqp_dsn: AmqpDsn = 'amqp://user:pass@localhost:5672/'

    special_function: ImportString[Callable[[Any], Any]] = 'math.cos'  # (4)!

    # to override domains:
    # export my_prefix_domains='["foo.com", "bar.com"]'
    domains: set[str] = set()

    # to override more_settings:
    # export my_prefix_more_settings='{"foo": "x", "apple": 1}'
    more_settings: SubModel = SubModel()

    model_config = SettingsConfigDict(env_prefix='my_prefix_')  # (5)!


print(Settings().model_dump())
"""
{
    'auth_key': 'xxx',
    'api_key': 'xxx',
    'redis_dsn': RedisDsn('redis://user:pass@localhost:6379/1'),
    'pg_dsn': PostgresDsn('postgres://user:pass@localhost:5432/foobar'),
    'amqp_dsn': AmqpDsn('amqp://user:pass@localhost:5672/'),
    'special_function': math.cos,
    'domains': set(),
    'more_settings': {'foo': 'bar', 'apple': 1},
}
"""

```

--------------------------------

### Custom Settings Source for Pydantic-Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Illustrates how to create a custom settings source in pydantic-settings by subclassing `EnvSettingsSource`. This custom source (`MyCustomSource`) overrides the `prepare_field_value` method to provide custom parsing logic for environment variables. The example shows how to parse a comma-separated string into a list of integers for the 'numbers' field and how to disable default JSON parsing for other fields by returning `json.loads(value)`. It demonstrates setting an environment variable and loading it into a `BaseSettings` model with the custom source.

```python
import json
import os
from typing import Any

from pydantic.fields import FieldInfo

from pydantic_settings import (
    BaseSettings,
    EnvSettingsSource,
    PydanticBaseSettingsSource,
)


class MyCustomSource(EnvSettingsSource):
    def prepare_field_value(
        self,
        field_name: str,
        field: FieldInfo,
        value: Any,
        value_is_complex: bool,
    ) -> Any:
        if field_name == 'numbers':
            return [int(x) for x in value.split(',')]
        return json.loads(value)


class Settings(BaseSettings):
    numbers: list[int]

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls: type[BaseSettings],
        init_settings: PydanticBaseSettingsSource,
        env_settings: PydanticBaseSettingsSource,
        dotenv_settings: PydanticBaseSettingsSource,
        file_secret_settings: PydanticBaseSettingsSource,
    ) -> tuple[PydanticBaseSettingsSource, ...]:
        return (MyCustomSource(settings_cls),)


os.environ['numbers'] = '1,2,3'
print(Settings().model_dump())
#> {'numbers': [1, 2, 3]}

```

--------------------------------

### Load LLM Configuration from Environment Variables using Pydantic-Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how to define and load nested LLM configurations from environment variables using Pydantic's BaseModel and pydantic-settings' BaseSettings. It highlights the use of `SettingsConfigDict` for custom environment variable parsing, specifically the `env_nested_delimiter` and `env_nested_max_split` options. This example shows how environment variables like `GENERATION_LLM_API_KEY` are mapped to nested model fields.

```python
export GENERATION_LLM_PROVIDER='anthropic'
export GENERATION_LLM_API_KEY='your-api-key'
export GENERATION_LLM_API_VERSION='2024-03-15'

from pydantic import BaseModel
from pydantic_settings import BaseSettings, SettingsConfigDict


class LLMConfig(BaseModel):
    provider: str = 'openai'
    api_key: str
    api_type: str = 'azure'
    api_version: str = '2023-03-15-preview'


class GenerationConfig(BaseSettings):
    model_config = SettingsConfigDict(
        env_nested_delimiter='_', env_nested_max_split=1, env_prefix='GENERATION_'
    )

    llm: LLMConfig
    ...


print(GenerationConfig().model_dump())
"""
{
    'llm': {
        'provider': 'anthropic',
        'api_key': 'your-api-key',
        'api_type': 'azure',
        'api_version': '2024-03-15',
    }
}
"""

# Without env_nested_max_split=1 set, GENERATION_LLM_API_KEY would be parsed as llm.api.key instead of llm.api_key
# and it would raise a ValidationError.

# Nested environment variables take precedence over the top-level environment variable JSON
# (e.g. in the example above, SUB_MODEL__V2 trumps SUB_MODEL).

```

--------------------------------

### Disable JSON Parsing Globally in Pydantic-Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how to disable JSON parsing for all fields in a pydantic-settings model by setting `enable_decoding=False` within the `SettingsConfigDict`. Similar to the `NoDecode` annotation, this requires custom validators to parse complex types from environment variables. The example defines a `Settings` model with a `numbers` field and a `field_validator` to handle the parsing of a comma-separated string, then sets the environment variable and prints the model dump.

```python
import os

from pydantic import field_validator

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(enable_decoding=False)

    numbers: list[int]

    @field_validator('numbers', mode='before')
    @classmethod
    def decode_numbers(cls, v: str) -> list[int]:
        return [int(x) for x in v.split(',')]


os.environ['numbers'] = '1,2,3'
print(Settings().model_dump())
#> {'numbers': [1, 2, 3]}

```

--------------------------------

### Load Nested Environment Variables with Pydantic Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates loading environment variables into a Pydantic settings model with nested structures. It utilizes `env_nested_delimiter` to parse variables like `SUB_MODEL__V2` into nested dictionaries and models. The example shows how JSON-encoded strings and nested variable names are handled, along with type conversions.

```python
from pydantic import BaseModel

from pydantic_settings import BaseSettings, SettingsConfigDict


class DeepSubModel(BaseModel):
    v4: str


class SubModel(BaseModel):
    v1: str
    v2: bytes
    v3: int
    deep: DeepSubModel


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_nested_delimiter='__')

    v0: str
    sub_model: SubModel


# Example environment variables:
# export V0=0
# export SUB_MODEL='{"v1": "json-1", "v2": "json-2"}'
# export SUB_MODEL__V2=nested-2
# export SUB_MODEL__V3=3
# export SUB_MODEL__DEEP__V4=v4


print(Settings().model_dump())

```

--------------------------------

### Load .env file using _env_file argument during instantiation

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Illustrates an alternative method to load environment variables from a specified .env file during the instantiation of a BaseSettings derived class using the '_env_file' keyword argument. Includes encoding specification.

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')


settings = Settings(_env_file='prod.env', _env_file_encoding='utf-8')
```

--------------------------------

### Set Environment Variable Prefix with Pydantic-Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Configure a prefix for all environment variables used to populate settings. This helps avoid naming conflicts and organizes environment variables. The `env_prefix` is applied to all fields unless an alias is specified.

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_prefix='my_prefix_')

    auth_key: str = 'xxx'  # will be read from `my_prefix_auth_key`
```

--------------------------------

### Load .env file using model_config in BaseSettings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how to configure pydantic-settings to load variables from a .env file by specifying 'env_file' in the model_config of a BaseSettings class. It also shows how to set the file encoding.

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')
```

--------------------------------

### Force JSON Parsing in Pydantic-Settings with ForceDecode

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Illustrates how to force JSON parsing for a specific field in pydantic-settings, even when global JSON decoding is disabled. This is achieved using the `ForceDecode` annotation from `typing.Annotated`. The example shows a `Settings` model where global decoding is turned off (`enable_decoding=False`), but the `numbers` field is annotated with `ForceDecode`, allowing it to be parsed from a JSON string environment variable. A second field, `numbers1`, is also included to show behavior without `ForceDecode`. Both environment variables are set, and the model dump is printed.

```python
import os
from typing import Annotated

from pydantic import field_validator

from pydantic_settings import BaseSettings, ForceDecode, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(enable_decoding=False)

    numbers: Annotated[list[int], ForceDecode]
    numbers1: list[int]  # (1)!

    @field_validator('numbers1', mode='before')
    @classmethod
    def decode_numbers1(cls, v: str) -> list[int]:
        return [int(x) for x in v.split(',')]


os.environ['numbers'] = '["1","2","3"]'
os.environ['numbers1'] = '1,2,3'
print(Settings().model_dump())
#> {'numbers': [1, 2, 3], 'numbers1': [1, 2, 3]}

```

--------------------------------

### Disable Configuration Sources with Pydantic-Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how to customize configuration source loading in Pydantic-Settings by overriding `settings_customise_sources`. This allows selective disabling of sources like environment variables or initialization arguments, ensuring only specified sources are used. It handles potential `ValidationError` if required fields are missing.

```python
from pydantic import ValidationError

from pydantic_settings import BaseSettings, PydanticBaseSettingsSource


class Settings(BaseSettings):
    my_api_key: str

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls: type[BaseSettings],
        init_settings: PydanticBaseSettingsSource,
        env_settings: PydanticBaseSettingsSource,
        dotenv_settings: PydanticBaseSettingsSource,
        file_secret_settings: PydanticBaseSettingsSource,
    ) -> tuple[PydanticBaseSettingsSource, ...]:
        # here we choose to ignore arguments from init_settings
        return env_settings, file_secret_settings


try:
    Settings(my_api_key='this is ignored')
except ValidationError as exc_info:
    print(exc_info)
    
```

--------------------------------

### Parse Dictionaries from CLI Args with Pydantic Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates parsing dictionary types from CLI arguments using Pydantic Settings. Supports JSON style (`--field='{"k1": 1, "k2": 2}'`) and environment variable style (`--field k1=1 --field k2=2`). These can be mixed with list forms.

```python
import sys

from pydantic_settings import BaseSettings


class Settings(BaseSettings, cli_parse_args=True):
    my_dict: dict[str, int]


sys.argv = ['example.py', '--my_dict', '{"k1":1,"k2":2}']
print(Settings().model_dump())

sys.argv = ['example.py', '--my_dict', 'k1=1', '--my_dict', 'k2=2']
print(Settings().model_dump())

```

--------------------------------

### Enable Case-Sensitive Environment Variables with Pydantic-Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Control the case sensitivity of environment variable names. By default, names are case-insensitive. Setting `case_sensitive=True` requires exact matches for environment variable names, considering the prefix.

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(case_sensitive=True)

    redis_host: str = 'localhost'
```

--------------------------------

### Use Field Alias to Override Environment Variable Name

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Specify a custom environment variable name for a single field using `Field(alias=...)` or `Field(validation_alias=...)`. This overrides any `env_prefix` configuration.

```python
from pydantic import Field

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_prefix='my_prefix_')

    foo: str = Field('xxx', alias='FooAlias')  # (1)!

# 1. `env_prefix` will be ignored and the value will be read from `FooAlias` environment variable.
```

--------------------------------

### In-place Setting Reloading with Pydantic-Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Illustrates how to reload settings in-place within a Pydantic-Settings model by calling its `__init__` method. This is useful for dynamically updating settings based on external changes, such as environment variables. The example shows how modifying environment variables affects the settings after reinitialization.

```python
import os

from pydantic import Field

from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    foo: str = Field('foo')


mutable_settings = Settings()

print(mutable_settings.foo)

os.environ['foo'] = 'bar'
print(mutable_settings.foo)

mutable_settings.__init__()
print(mutable_settings.foo)

os.environ.pop('foo')
mutable_settings.__init__()
print(mutable_settings.foo)

```

--------------------------------

### Disable JSON Parsing in Pydantic-Settings with NoDecode

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Shows how to disable automatic JSON parsing for specific fields in pydantic-settings using the `NoDecode` annotation from `typing.Annotated`. This forces the field's value to be processed by a custom validator, as demonstrated with the `decode_numbers` field validator which parses a comma-separated string into a list of integers. The example also sets the environment variable and prints the resulting model dump.

```python
import os
from typing import Annotated

from pydantic import field_validator

from pydantic_settings import BaseSettings, NoDecode


class Settings(BaseSettings):
    numbers: Annotated[list[int], NoDecode]  # (1)!

    @field_validator('numbers', mode='before')
    @classmethod
    def decode_numbers(cls, v: str) -> list[int]:
        return [int(x) for x in v.split(',')]


os.environ['numbers'] = '1,2,3'
print(Settings().model_dump())
#> {'numbers': [1, 2, 3]}

```

--------------------------------

### Integrate pydantic-settings with Existing Parsers

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Explains how to integrate pydantic-settings CLI parsing with pre-existing `argparse.ArgumentParser` instances. This is done by overriding the default CLI settings source with a custom one, specifying the `root_parser` to enable combined parsing of CLI arguments.

```Python
import sys
from argparse import ArgumentParser

from pydantic_settings import BaseSettings, CliApp, CliSettingsSource

parser = ArgumentParser()
parser.add_argument('--food', choices=['pear', 'kiwi', 'lime'])


class Settings(BaseSettings):
    name: str = 'Bob'


# Set existing `parser` as the `root_parser` object for the user defined settings source
cli_settings = CliSettingsSource(Settings, root_parser=parser)

# Parse and load CLI settings from the command line into the settings source.
sys.argv = ['example.py', '--food', 'kiwi', '--name', 'waldo']
s = CliApp.run(Settings, cli_settings_source=cli_settings)
print(s.model_dump())
#> {'name': 'waldo'}

# Load CLI settings from pre-parsed arguments. i.e., the parsing occurs elsewhere and we
```

--------------------------------

### Parse Nested Settings from CLI Args with Pydantic

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates parsing nested Pydantic models directly from CLI arguments. It utilizes `SettingsConfigDict(cli_parse_args=True)` to enable this functionality. Nested arguments are specified using dot notation.

```python
import sys

from pydantic import BaseModel

from pydantic_settings import BaseSettings, SettingsConfigDict


class DeepSubModel(BaseModel):
    v4: str


class SubModel(BaseModel):
    v1: str
    v2: bytes
    v3: int
    deep: DeepSubModel


class Settings(BaseSettings):
    model_config = SettingsConfigDict(cli_parse_args=True)

    v0: str
    sub_model: SubModel


sys.argv = [
    'example.py',
    '--v0=0',
    '--sub_model={"v1": "json-1", "v2": "json-2"}',
    '--sub_model.v2=nested-2',
    '--sub_model.v3=3',
    '--sub_model.deep.v4=v4',
]

print(Settings().model_dump())

```

--------------------------------

### Run Pydantic Settings as CLI App

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how to use `CliApp.run` to execute a Pydantic `BaseSettings` model as a CLI application. It shows how to define a `cli_cmd` method and pass CLI arguments for parsing and execution.

```python
from pydantic_settings import BaseSettings, CliApp


class Settings(BaseSettings):
    this_foo: str

    def cli_cmd(self) -> None:
        # Print the parsed data
        print(self.model_dump())
        #> {'this_foo': 'is such a foo'}

        # Update the parsed data showing cli_cmd ran
        self.this_foo = 'ran the foo cli cmd'


s = CliApp.run(Settings, cli_args=['--this_foo', 'is such a foo'])
print(s.model_dump())
#> {'this_foo': 'ran the foo cli cmd'}
```

--------------------------------

### Parse Lists from CLI Args with Pydantic Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Shows how Pydantic Settings handles list parsing from CLI arguments using multiple styles: JSON (`--field='[1,2]'`), Argparse (`--field 1 --field 2`), and Lazy (`--field=1,2`).

```python
import sys

from pydantic_settings import BaseSettings


class Settings(BaseSettings, cli_parse_args=True):
    my_list: list[int]


sys.argv = ['example.py', '--my_list', '[1,2]']
print(Settings().model_dump())

sys.argv = ['example.py', '--my_list', '1', '--my_list', '2']
print(Settings().model_dump())

sys.argv = ['example.py', '--my_list', '1,2']
print(Settings().model_dump())

```

--------------------------------

### Define Git Subcommands with Pydantic Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

This example demonstrates how to define a `BaseSettings` class with two subcommands, 'clone' and 'init', using `CliSubCommand`. It shows how to parse arguments and retrieve subcommand data, including error handling when no subcommand is provided and successful parsing when arguments are present. Dependencies include `pydantic` and `pydantic_settings`. It takes command-line arguments as input and outputs parsed model data.

```python
import sys

from pydantic import BaseModel

from pydantic_settings import (
    BaseSettings,
    CliPositionalArg,
    CliSubCommand,
    SettingsError,
    get_subcommand,
)


class Init(BaseModel):
    directory: CliPositionalArg[str]


class Clone(BaseModel):
    repository: CliPositionalArg[str]
    directory: CliPositionalArg[str]


class Git(BaseSettings, cli_parse_args=True, cli_exit_on_error=False):
    clone: CliSubCommand[Clone]
    init: CliSubCommand[Init]


# Run without subcommands
sys.argv = ['example.py']
cmd = Git()
assert cmd.model_dump() == {'clone': None, 'init': None}

try:
    # Will raise an error since no subcommand was provided
    get_subcommand(cmd).model_dump()
except SettingsError as err:
    assert str(err) == 'Error: CLI subcommand is required {clone, init}'

# Will not raise an error since subcommand is not required
assert get_subcommand(cmd, is_required=False) is None


# Run the clone subcommand
sys.argv = ['example.py', 'clone', 'repo', 'dest']
cmd = Git()
assert cmd.model_dump() == {
    'clone': {'repository': 'repo', 'directory': 'dest'},
    'init': None,
}

# Returns the subcommand model instance (in this case, 'clone')
assert get_subcommand(cmd).model_dump() == {
    'directory': 'dest',
    'repository': 'repo',
}

```

--------------------------------

### Change Settings Priority with `settings_customise_sources`

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how to change the priority of settings sources by reordering the callables returned by `settings_customise_sources`. In this example, environment variables are given precedence over initialization arguments.

```python
from pydantic import PostgresDsn

from pydantic_settings import BaseSettings, PydanticBaseSettingsSource


class Settings(BaseSettings):
    database_dsn: PostgresDsn

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls: type[BaseSettings],
        init_settings: PydanticBaseSettingsSource,
        env_settings: PydanticBaseSettingsSource,
        dotenv_settings: PydanticBaseSettingsSource,
        file_secret_settings: PydanticBaseSettingsSource,
    ) -> tuple[PydanticBaseSettingsSource, ...]:
        return env_settings, init_settings, file_secret_settings


print(Settings(database_dsn='postgres://postgres@localhost:5432/kwargs_db'))
#> database_dsn=PostgresDsn('postgres://postgres@localhost:5432/kwargs_db')
```

--------------------------------

### Customize Settings Sources with CLI in Pydantic

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Illustrates how to customize the order and inclusion of settings sources in Pydantic, specifically prioritizing CLI arguments. It uses `CliSettingsSource` and overrides `settings_customise_sources` to achieve this. Environment variables are also shown as a lower priority source.

```python
import os
import sys

from pydantic_settings import (
    BaseSettings,
    CliSettingsSource,
    PydanticBaseSettingsSource,
)


class Settings(BaseSettings):
    my_foo: str

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls: type[BaseSettings],
        init_settings: PydanticBaseSettingsSource,
        env_settings: PydanticBaseSettingsSource,
        dotenv_settings: PydanticBaseSettingsSource,
        file_secret_settings: PydanticBaseSettingsSource,
    ) -> tuple[PydanticBaseSettingsSource, ...]:
        return env_settings, CliSettingsSource(settings_cls, cli_parse_args=True)


os.environ['MY_FOO'] = 'from environment'

sys.argv = ['example.py', '--my_foo=from cli']

print(Settings().model_dump())

```

--------------------------------

### Load Parsed Args into Pydantic Settings (Python)

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates loading pre-parsed command-line arguments into a Pydantic settings model. It utilizes `CliApp.run` to manage the settings initialization with provided CLI arguments.

```python
from pydantic_settings import BaseSettings, SettingsConfigDict

# Assuming 'parser' and 'CliApp' are defined elsewhere
# parsed_args = parser.parse_args(['--food', 'kiwi', '--name', 'ralph'])
# s = CliApp.run(Settings, cli_args=parsed_args, cli_settings_source=cli_settings)
# print(s.model_dump())

```

--------------------------------

### Configure Pydantic Settings for Nested Partial Updates

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how to enable or disable partial updates for nested model defaults in Pydantic settings using the `nested_model_default_partial_update` flag. This flag controls whether environment variables partially update existing nested model instances or create new ones. It requires the `pydantic-settings` library.

```python
import os

from pydantic import BaseModel

from pydantic_settings import BaseSettings, SettingsConfigDict


class SubModel(BaseModel):
    val: int = 0
    flag: bool = False


class SettingsPartialUpdate(BaseSettings):
    model_config = SettingsConfigDict(
        env_nested_delimiter='__', nested_model_default_partial_update=True
    )

    nested_model: SubModel = SubModel(val=1)


class SettingsNoPartialUpdate(BaseSettings):
    model_config = SettingsConfigDict(
        env_nested_delimiter='__', nested_model_default_partial_update=False
    )

    nested_model: SubModel = SubModel(val=1)


# Apply a partial update to the default object using environment variables
os.environ['NESTED_MODEL__FLAG'] = 'True'

# When partial update is enabled, the existing SubModel instance is updated
# with nested_model.flag=True change
assert SettingsPartialUpdate().model_dump() == {
    'nested_model': {'val': 1, 'flag': True}
}

# When partial update is disabled, a new SubModel instance is instantiated
# with nested_model.flag=True change
assert SettingsNoPartialUpdate().model_dump() == {
    'nested_model': {'val': 0, 'flag': True}
}
```

--------------------------------

### Parse Literals and Enums from CLI Args with Pydantic

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Shows how Pydantic Settings automatically converts literal types and enums into CLI choices when `cli_parse_args=True` is set. The example includes an `IntEnum` and a `Literal` type.

```python
import sys
from enum import IntEnum
from typing import Literal

from pydantic_settings import BaseSettings


class Fruit(IntEnum):
    pear = 0
    kiwi = 1
    lime = 2


class Settings(BaseSettings, cli_parse_args=True):
    fruit: Fruit
    pet: Literal['dog', 'cat', 'bird']


sys.argv = ['example.py', '--fruit', 'lime', '--pet', 'cat']
print(Settings().model_dump())

```

--------------------------------

### Disable Default Value Validation in BaseSettings (Python)

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Shows how to disable the default validation of default values in Pydantic BaseSettings models. This can be done globally via `model_config` or on a per-field basis using `Field(validate_default=False)`. The example demonstrates that the string 'test' is accepted for an integer field when validation is off.

```python
from pydantic import Field

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(validate_default=False)

    # default won't be validated
    foo: int = 'test'


print(Settings())
#> foo='test'


class Settings1(BaseSettings):
    # default won't be validated
    foo: int = Field('test', validate_default=False)


print(Settings1())
#> foo='test'

```

--------------------------------

### Handle Case-Sensitivity in Nested Pydantic-Settings Models

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how `case_sensitive` setting applies to nested models. When `case_sensitive=True`, environment variables must match nested field names exactly. This example shows a `ValidationError` when the case does not match.

```python
import os

from pydantic import BaseModel, ValidationError

from pydantic_settings import BaseSettings


class RedisSettings(BaseModel):
    host: str
    port: int


class Settings(BaseSettings, case_sensitive=True):
    redis: RedisSettings


os.environ['redis'] = '{"host": "localhost", "port": 6379}'
print(Settings().model_dump())
#> {'redis': {'host': 'localhost', 'port': 6379}}
os.environ['redis'] = '{"HOST": "localhost", "port": 6379}'  # (1)!
try:
    Settings()
except ValidationError as e:
    print(e)
    """
    1 validation error for Settings
    redis.host
      Field required [type=missing, input_value={'HOST': 'localhost', 'port': 6379}, input_type=dict]
        For further information visit https://errors.pydantic.dev/2/v/missing
    """

# 1. Note that the `host` field is not found because the environment variable name is `HOST` (all upper-case).
```

--------------------------------

### Customize None Type Parse String in Pydantic Settings CLI

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Allows customization of the string value that will be parsed into `None` in the CLI. By setting `cli_parse_none_str`, you can define a specific keyword (e.g., 'void', 'null', 'None') that the CLI will recognize as a null value. This is useful for providing flexible input options.

```python
import sys
from typing import Optional

from pydantic import Field

from pydantic_settings import BaseSettings


class Settings(BaseSettings, cli_parse_args=True, cli_parse_none_str='void'):
    v1: Optional[int] = Field(description='the top level v0 option')


sys.argv = ['example.py', '--v1', 'void']
print(Settings().model_dump())
#> {'v1': None}
```

--------------------------------

### Change CLI Flag Prefix Character in pydantic-settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how to modify the default prefix character ('--') for CLI optional arguments by setting `cli_flag_prefix_char` in the BaseSettings class. This allows for custom argument naming conventions.

```Python
import sys

from pydantic import AliasChoices, Field

from pydantic_settings import BaseSettings


class Settings(BaseSettings, cli_parse_args=True, cli_flag_prefix_char='+'):
    my_arg: str = Field(validation_alias=AliasChoices('m', 'my-arg'))


sys.argv = ['example.py', '++my-arg', 'hi']
print(Settings().model_dump())
#> {'my_arg': 'hi'}

sys.argv = ['example.py', '+m', 'hi']
print(Settings().model_dump())
#> {'my_arg': 'hi'}
```

--------------------------------

### Integrate AWS Secrets Manager with Pydantic Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Sets up Pydantic Settings to load configurations from AWS Secrets Manager. It requires the AWS_SECRETS_MANAGER_SECRET_ID environment variable to be set. Nested models are supported using '--' separators, but arrays are not. Ensure your AWS credentials and permissions are configured.

```python
import os

from pydantic import BaseModel

from pydantic_settings import (
    AWSSecretsManagerSettingsSource,
    BaseSettings,
    PydanticBaseSettingsSource,
)


class SubModel(BaseModel):
    a: str


class AWSSecretsManagerSettings(BaseSettings):
    foo: str
    bar: int
    sub: SubModel

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls: type[BaseSettings],
        init_settings: PydanticBaseSettingsSource,
        env_settings: PydanticBaseSettingsSource,
        dotenv_settings: PydanticBaseSettingsSource,
        file_secret_settings: PydanticBaseSettingsSource,
    ) -> tuple[PydanticBaseSettingsSource, ...]:
        aws_secrets_manager_settings = AWSSecretsManagerSettingsSource(
            settings_cls,
            os.environ['AWS_SECRETS_MANAGER_SECRET_ID'],
        )
        return (
            init_settings,
            env_settings,
            dotenv_settings,
            file_secret_settings,
            aws_secrets_manager_settings,
        )
```

--------------------------------

### Ignore .env file loading using _env_file=None

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how to explicitly prevent loading any .env file during instantiation, even if one is defined in model_config, by passing '_env_file=None'.

```python
settings = Settings(_env_file=None)
```

--------------------------------

### Enforce Required Arguments at CLI with Pydantic Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Enables strict enforcement of required fields directly at the command line interface when instantiating Pydantic Settings models. This ensures that if a field is marked as required, it must be provided via the CLI, even if it's available from other sources like environment variables. A required `CliPositionalArg` field is always strictly enforced.

```python
import os
import sys

from pydantic import Field

from pydantic_settings import BaseSettings, SettingsError


class Settings(
    BaseSettings,
    cli_parse_args=True,
    cli_enforce_required=True,
    cli_exit_on_error=False,
):
    my_required_field: str = Field(description='a top level required field')


os.environ['MY_REQUIRED_FIELD'] = 'hello from environment'

try:
    sys.argv = ['example.py']
    Settings()
except SettingsError as e:
    print(e)
    #> error parsing CLI: the following arguments are required: --my_required_field
```

--------------------------------

### Customize Pydantic CLI Program Name

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how to customize the program name displayed in the CLI help message by setting the `cli_prog_name` attribute in the `BaseSettings` class. This allows for branding or clearer identification of the application.

```python
import sys

from pydantic_settings import BaseSettings


class Settings(BaseSettings, cli_parse_args=True, cli_prog_name='appdantic'):
    pass


try:
    sys.argv = ['example.py', '--help']
    Settings()
except SystemExit as e:
    print(e)
    #> 0
"""
usage: appdantic [-h]

options:
  -h, --help  show this help message and exit
"""
```

--------------------------------

### Avoid Adding JSON CLI Options with Pydantic Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Prevents Pydantic Settings from automatically generating CLI options for complex fields that would typically be parsed as JSON strings. By enabling `cli_avoid_json`, the CLI interface is simplified, especially for nested models, focusing on direct argument parsing.

```python
import sys

from pydantic import BaseModel, Field

from pydantic_settings import BaseSettings


class SubModel(BaseModel):
    v1: int = Field(description='the sub model v1 option')


class Settings(BaseSettings, cli_parse_args=True, cli_avoid_json=True):
    sub_model: SubModel = Field(
        description='The help summary for SubModel related options'
    )


try:
    sys.argv = ['example.py', '--help']
    Settings()
except SystemExit as e:
    print(e)
    #> 0
"""
usage: example.py [-h] [--sub_model.v1 int]

options:
  -h, --help          show this help message and exit

sub_model options:
  The help summary for SubModel related options

  --sub_model.v1 int  the sub model v1 option (required)
"""
```

--------------------------------

### Handle extra fields in .env files with extra='ignore'

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Provides an example of how to configure pydantic-settings to ignore extra fields found in a .env file that are not defined in the settings model. This is useful for compatibility with pydantic v1.x.

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file='.env', extra='ignore')
```

--------------------------------

### Load Settings from Default pyproject.toml Table

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates loading Pydantic settings from the default `[tool.pydantic-settings]` table in pyproject.toml. This utilizes PyprojectTomlConfigSettingsSource with default settings.

```python
from pydantic_settings import (
    BaseSettings,
    PydanticBaseSettingsSource,
    PyprojectTomlConfigSettingsSource,
    SettingsConfigDict,
)


class Settings(BaseSettings):
    """Example loading values from the table used by default."""

    field: str

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls: type[BaseSettings],
        init_settings: PydanticBaseSettingsSource,
        env_settings: PydanticBaseSettingsSource,
        dotenv_settings: PydanticBaseSettingsSource,
        file_secret_settings: PydanticBaseSettingsSource,
    ) -> tuple[PydanticBaseSettingsSource, ...]:
        return (PyprojectTomlConfigSettingsSource(settings_cls),)


class SomeTableSettings(Settings):
    """Example loading values from a user defined table."""

    model_config = SettingsConfigDict(
        pyproject_toml_table_header=('tool', 'some-table')
    )


class RootSettings(Settings):
    """Example loading values from the root of a pyproject.toml file."""

    model_config = SettingsConfigDict(extra='ignore', pyproject_toml_table_header=())

```

--------------------------------

### Integrate Azure Key Vault with Pydantic Settings

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Configures Pydantic Settings to retrieve secrets from Azure Key Vault. It requires the AZURE_KEY_VAULT_URL environment variable and uses DefaultAzureCredential for authentication. Local authentication can be achieved via `az login`. Nested models are supported with '--' separators, but arrays are not.

```python
import os

from azure.identity import DefaultAzureCredential
from pydantic import BaseModel

from pydantic_settings import (
    AzureKeyVaultSettingsSource,
    BaseSettings,
    PydanticBaseSettingsSource,
)


class SubModel(BaseModel):
    a: str


class AzureKeyVaultSettings(BaseSettings):
    foo: str
    bar: int
    sub: SubModel

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls: type[BaseSettings],
        init_settings: PydanticBaseSettingsSource,
        env_settings: PydanticBaseSettingsSource,
        dotenv_settings: PydanticBaseSettingsSource,
        file_secret_settings: PydanticBaseSettingsSource,
    ) -> tuple[PydanticBaseSettingsSource, ...]:
        az_key_vault_settings = AzureKeyVaultSettingsSource(
            settings_cls,
            os.environ['AZURE_KEY_VAULT_URL'],
            DefaultAzureCredential(),
        )
        return (
            init_settings,
            env_settings,
            dotenv_settings,
            file_secret_settings,
            az_key_vault_settings,
        )
```

--------------------------------

### Handle Pydantic Field Aliases as CLI Args

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Demonstrates how Pydantic's field aliases, including short options and `AliasPath`, are automatically recognized as CLI argument aliases when using Pydantic Settings with CLI parsing enabled. Alias choices allow multiple names for a single field.

```python
import sys

from pydantic import AliasChoices, AliasPath, Field

from pydantic_settings import BaseSettings


class User(BaseSettings, cli_parse_args=True):
    first_name: str = Field(
        validation_alias=AliasChoices('f', 'fname', AliasPath('name', 0))
    )
    last_name: str = Field(
        validation_alias=AliasChoices('l', 'lname', AliasPath('name', 1))
    )


sys.argv = ['example.py', '--fname', 'John', '--lname', 'Doe']
print(User().model_dump())

sys.argv = ['example.py', '-f', 'John', '-l', 'Doe']
print(User().model_dump())

sys.argv = ['example.py', '--name', 'John,Doe']
print(User().model_dump())

sys.argv = ['example.py', '--name', 'John', '--lname', 'Doe']
print(User().model_dump())

```

--------------------------------

### Example pyproject.toml Structure

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Illustrates the structure of a pyproject.toml file that can be parsed by Pydantic settings. It shows settings defined at the root, within `[tool.pydantic-settings]`, and within a custom table `[tool.some-table]`.

```toml
field = "root"

[tool.pydantic-settings]
field = "default-table"

[tool.some-table]
field = "some-table"

```

--------------------------------

### Run Pydantic Settings with Async CLI Command

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Shows how to define and run an asynchronous CLI command using `CliApp.run` with an `async def cli_cmd` method in a `BaseSettings` model. It handles event loop management automatically.

```python
from pydantic_settings import BaseSettings, CliApp


class AsyncSettings(BaseSettings):
    async def cli_cmd(self) -> None:
        print('Hello from an async CLI method!')
        #> Hello from an async CLI method!


# If an event loop is already running, a new thread will be used;
# otherwise, asyncio.run() is used to execute this async method.
assert CliApp.run(AsyncSettings, cli_args=[]).model_dump() == {}
```

--------------------------------

### Access Previous Settings in Custom Source

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Shows how a custom settings source can access the aggregated results from previously processed sources using `self.current_state` or `self.settings_sources_data`.

```python
from typing import Any

from pydantic.fields import FieldInfo

from pydantic_settings import PydanticBaseSettingsSource


class MyCustomSource(PydanticBaseSettingsSource):
    def get_field_value(
        self,
        field: FieldInfo,
        field_name: str
    ) -> tuple[Any, str, bool]: ...

    def __call__(self) -> dict[str, Any]:
        # Retrieve the aggregated settings from previous sources
        current_state = self.current_state
        current_state.get('some_setting')

        # Retrive settings from all sources individually
        # self.settings_sources_data["SettingsSourceName"]: dict[str, Any]
        settings_sources_data = self.settings_sources_data
        settings_sources_data['SomeSettingsSource'].get('some_setting')

        # Your code here...
```

--------------------------------

### Add Custom JSON Settings Source

Source: https://github.com/pydantic/pydantic-settings/blob/main/docs/index.md

Illustrates adding a custom settings source that reads configuration from a JSON file. The `JsonConfigSettingsSource` class implements `get_field_value` and `prepare_field_value` to load data from `tests/example_test_config.json`.

```python
import json
from pathlib import Path
from typing import Any

from pydantic.fields import FieldInfo

from pydantic_settings import (
    BaseSettings,
    PydanticBaseSettingsSource,
    SettingsConfigDict,
)


class JsonConfigSettingsSource(PydanticBaseSettingsSource):
    """
    A simple settings source class that loads variables from a JSON file
    at the project's root.

    Here we happen to choose to use the `env_file_encoding` from Config
    when reading `config.json`
    """

    def get_field_value(
        self,
        field: FieldInfo,
        field_name: str
    ) -> tuple[Any, str, bool]:
        encoding = self.config.get('env_file_encoding')
        file_content_json = json.loads(
            Path('tests/example_test_config.json').read_text(encoding)
        )
        field_value = file_content_json.get(field_name)
        return field_value, field_name, False

    def prepare_field_value(
        self,
        field_name: str,
        field: FieldInfo,
        value: Any,
        value_is_complex: bool
    ) -> Any:
        return value

    def __call__(self) -> dict[str, Any]:
        d: dict[str, Any] = {}

        for field_name, field in self.settings_cls.model_fields.items():
            field_value, field_key, value_is_complex = self.get_field_value(
                field,
                field_name
            )
            field_value = self.prepare_field_value(
                field_name,
                field,
                field_value,
                value_is_complex
            )
            if field_value is not None:
                d[field_key] = field_value

        return d


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file_encoding='utf-8')

    foobar: str

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls: type[BaseSettings],
        init_settings: PydanticBaseSettingsSource,
        env_settings: PydanticBaseSettingsSource,
        dotenv_settings: PydanticBaseSettingsSource,
        file_secret_settings: PydanticBaseSettingsSource,
    ) -> tuple[PydanticBaseSettingsSource, ...]:
        return (
            init_settings,
            JsonConfigSettingsSource(settings_cls),
            env_settings,
            file_secret_settings,
        )


print(Settings())
#> foobar='test'
```